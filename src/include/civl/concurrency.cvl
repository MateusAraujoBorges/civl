/* This file completes the definitions of types and some functions
 * for concurrency, which are declared in concurrency.cvh.
 */
 
#ifndef __CIVLC_CONCURRENCY__
#define __CIVLC_CONCURRENCY__

#include<concurrency.cvh>
#include<seq.cvh>

/* *********************** Types *********************** */

/* A data type representing a global barrier which must be operated by local
 * barriers.  Completes the declaration of this type in civlc-common.h.
 */
struct _gbarrier {
  int nprocs;
  $proc proc_map[]; // initialized as all $proc_null.
  _Bool in_barrier[]; // initialized as all false.
  int num_in_barrier; // initialized as 0.
};

/* A data type representing a global barrier which used for 
 * operating global barriers. The local barrier type has 
 * a handle of a global barrier.
 * Completes the declaration of this type in civlc-common.h.
 */
struct _barrier {
  int place;
  $gbarrier gbarrier; // initialized as 0.
};

/******************* Collective Arrive Checking Records *******************/
/* Record entry */
struct _collator_entry {
  $bundle entries;
  _Bool marks[];  //an array stores marks for processes
  int numMarked;  //number of processes already marked this record
};

/* Global records queue */
struct _gcollator {
  int length;
  $collator_entry entries[];
};

/* Local handle of the global records queue */
struct _collator {
  $gcollator gcollator;
};

/* *********************** Functions *********************** */

/*@ depends_on \access(barrier);
  @ assigns \nothing;
  @ executes_when \true;
  @ */ 
$system void $barrier_enter($barrier barrier);

/*@ depends_on \access(barrier);
  @ assigns \nothing;
  @ */
$system void $barrier_exit($barrier barrier);

void $barrier_call($barrier barrier) {
  $barrier_enter(barrier);
  $barrier_exit(barrier);
}


/*@ depends_on \nothing;
  @ assigns \nothing;
  @ reads \nothing;
  @ */
$atomic_f $gbarrier $gbarrier_create($scope scope, int size){
  $gbarrier gbarrier = ($gbarrier)$malloc(scope, sizeof(struct _gbarrier));

  gbarrier->nprocs=size;
  gbarrier->proc_map=($proc[size])$lambda(int i) $proc_null;
  gbarrier->in_barrier=(_Bool[size])$lambda(int i) $false;
  gbarrier->num_in_barrier=0;
  return gbarrier;
}

/*@ depends_on \access(gbarrier);
  @ reads \nothing;
  @ assigns gbarrier;
  @ */
$atomic_f void $gbarrier_destroy($gbarrier gbarrier){
  $free(gbarrier);
}

/*@ depends_on \nothing;
  @ assigns gbarrier;
  @ reads gbarrier;
  @ */
$atomic_f $barrier $barrier_create($scope scope, $gbarrier gbarrier, int place){
  $assert(gbarrier->proc_map[place]==$proc_null, "the place %d in the global barrier has already been taken.", place);

  $barrier barrier=($barrier)$malloc(scope, sizeof(struct _barrier));

  barrier->place=place;
  barrier->gbarrier=gbarrier;
  gbarrier->proc_map[place]=$self;
  return barrier;
}

/*@ depends_on \access(barrier);
  @ assigns barrier;
  @ reads \nothing;
  @ */
$atomic_f void $barrier_destroy($barrier barrier){
  $free(barrier);
}

/*@ depends_on \nothing;
  @ reads \nothing;
  @ assigns \nothing;
  @ */
$atomic_f $gcollator $gcollator_create($scope scope){
  $gcollator gcollator=($gcollator)$malloc(scope, sizeof(struct _gcollator));

  gcollator->length=0;
  $seq_init(&gcollator->entries, 0, NULL);
  return gcollator;
}

/*@ depends_on \access(gcollator);
  @ assigns gcollator;
  @ reads \nothing;
  @ */
$atomic_f int $gcollator_destroy($gcollator gcollator){
  int numRemaining=gcollator->length;

  $free(gcollator);
  return numRemaining;
}

/*@ depends_on \nothing;
  @ executes_when \true;
  @ */
$atomic_f $collator $collator_create($scope scope, $gcollator gcollator){
  $collator collator=($collator)$malloc(scope, sizeof(struct _collator));
  
  collator->gcollator=gcollator;
  return collator;
}

/*@ depends_on \access(collator);
  @ executes_when \true;
  @ */
$atomic_f void $collator_destroy($collator collator){
  $free(collator);
}
#endif
