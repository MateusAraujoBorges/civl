/* This file completes the definitions of types and some functions
 * for concurrency, which are declared in concurrency.cvh.
 */
 
#ifndef __CIVLC_CONCURRENCY__
#define __CIVLC_CONCURRENCY__

#include<concurrency.cvh>
#include<seq.cvh>

/* *********************** Types *********************** */

/* A data type representing a global barrier which must be operated by local
 * barriers.  Completes the declaration of this type in civlc-common.h.
 */
struct _gbarrier {
  int nprocs;
  $proc proc_map[]; // initialized as all $proc_null.
  _Bool in_barrier[]; // initialized as all false.
  int num_in_barrier; // initialized as 0.
};

/* A data type representing a global barrier which used for 
 * operating global barriers. The local barrier type has 
 * a handle of a global barrier.
 * Completes the declaration of this type in civlc-common.h.
 */
struct _barrier {
  int place;
  $gbarrier gbarrier; // initialized as 0.
};

/******************* Collective Arrive Checking Records *******************/
/* Record entry */
struct _collect_record {
  $bundle entries;
  _Bool marks[];  //an array stores marks for processes
  int numMarked;  //number of processes already marked this record
};

/* Global records queue */
struct _gcollect_checker {
  int length;
  $collect_record records[];
};

/* Local handle of the global records queue */
struct _collect_checker {
  $gcollect_checker checker;
};

/* *********************** Functions *********************** */

/*@ depends_on \nothing;
  @ assigns \nothing;
  @ executes_when \true;
  @ */ 
$system void $barrier_enter($barrier barrier);

/*@ depends_on \nothing;
  @ assigns \nothing;
  @ */
$system void $barrier_exit($barrier barrier);

/*@ pure;
  @ depends_on \nothing;
  @ executes_when \true;
  @ */
$atomic_f void $barrier_call($barrier barrier) {
  $barrier_enter(barrier);
  $barrier_exit(barrier);
}


/*@ depends_on \nothing;
  @ assigns \nothing;
  @ reads \nothing;
  @ */
$atomic_f $gbarrier $gbarrier_create($scope scope, int size){
  $gbarrier gbarrier = ($gbarrier)$malloc(scope, sizeof(struct _gbarrier));

  gbarrier->nprocs=size;
  gbarrier->proc_map=($proc[size])$lambda(int i) $proc_null;
  gbarrier->in_barrier=(_Bool[size])$lambda(int i) $false;
  gbarrier->num_in_barrier=0;
  return gbarrier;
}

/*@ depends_on \access(gbarrier);
  @ reads \nothing;
  @ assigns gbarrier;
  @ */
$atomic_f void $gbarrier_destroy($gbarrier gbarrier){
  $free(gbarrier);
}

/*@ depends_on \nothing;
  @ assigns gbarrier;
  @ reads gbarrier;
  @ */
$atomic_f $barrier $barrier_create($scope scope, $gbarrier gbarrier, int place){
  $assert(gbarrier->proc_map[place]==$proc_null, "the place %d in the global barrier has already been taken.", place);

  $barrier barrier=($barrier)$malloc(scope, sizeof(struct _barrier));

  barrier->place=place;
  barrier->gbarrier=gbarrier;
  gbarrier->proc_map[place]=$self;
  return barrier;
}

/*@ depends_on \access(barrier);
  @ assigns barrier;
  @ reads \nothing;
  @ */
$atomic_f void $barrier_destroy($barrier barrier){
  $free(barrier);
}

/*@ depends_on \nothing;
  @ reads \nothing;
  @ assigns \nothing;
  @ */
$atomic_f $gcollect_checker $gcollect_checker_create($scope scope){
  $gcollect_checker gchecker=($gcollect_checker)$malloc(scope, sizeof(struct _gcollect_checker));

  gchecker->length=0;
  $seq_init(&gchecker->records, 0, NULL);
  return gchecker;
}

/*@ depends_on \access(checker);
  @ assigns checker;
  @ reads \nothing;
  @ */
$atomic_f int $gcollect_checker_destroy($gcollect_checker checker){
  int numRemaining=checker->length;

  $free(checker);
  return numRemaining;
}

/*@ depends_on \nothing;
  @ executes_when \true;
  @ */
$atomic_f $collect_checker $collect_checker_create($scope scope, 
						   $gcollect_checker gchecker){
  $collect_checker checker=($collect_checker)$malloc(scope, sizeof(struct _collect_checker));
  
  checker->checker=gchecker;
  return checker;
}

/*@ depends_on \nothing;
  @ executes_when \true;
  @ */
$atomic_f void $collect_checker_destroy($collect_checker checker){
  $free(checker);
}
#endif
